# keystore基本使用

keystore的最基本使用方法

# 参考文档

* [由硬件支持的密钥库](https://source.android.com/security/keystore)
* [Android KeyStore流程](https://blog.csdn.net/jackone12347/article/details/122252644)
* [Verifying hardware-backed key pairs with Key Attestation](https://developer.android.google.cn/training/articles/security-key-attestation.html#verifying)
* [security-samples](https://github.com/android/security-samples)

# 术语

* AndroidKeystore: 是供应用访问 Keystore 功能的 Android Framework API 和组件。它是作为标准 Java Cryptography Architecture API 的扩展程序实现的，包含在应用自己的进程空间中运行的 Java 代码。AndroidKeystore 通过将与密钥库行为有关的应用请求转发到密钥库守护程序来执行这些请求。
* 密钥库守护程序是: Android 系统中的一个守护程序，该进程通过 Binder API 提供对所有密钥库功能的访问权限。密钥库守护程序负责存储“密钥 Blob”。密钥 Blob 中包含已加密的实际密钥材料，因此密钥库可以存储这些材料，但无法使用或显示这些材料。
* keymasterd: 是一个 HIDL 服务器，可提供对 Keymaster TA 的访问权限。（此名称未进行标准化，仅用于说明概念。）
* Keymaster TA（可信应用）: 是在安全环境（大多数情况为 ARM SoC 上的 TrustZone）中运行的软件。它可提供所有安全的密钥库操作，能够访问原始密钥材料，在密钥上验证所有访问控制条件，等等。
* LockSettingsService: 是负责用户身份验证（包括密码和指纹）的 Android 系统组件。它不是密钥库的一部分却与其相关，因为很多密钥库密钥操作都需要对用户进行身份验证。LockSettingsService 与 Gatekeeper TA 和 Fingerprint TA 进行交互以获取身份验证令牌，并将其提供给密钥库守护程序，这些令牌最终将由 Keymaster TA 应用使用。
* Gatekeeper TA（可信应用）: 是在安全环境中运行的另一个组件，它负责验证用户密码并生成身份验证令牌（用于向 Keymaster TA 证明已在特定时间点完成对特定用户的身份验证）。
* Fingerprint TA（可信应用）: 是在安全环境中运行的另一个组件，它负责验证用户指纹并生成身份验证令牌（用于向 Keymaster TA 证明已在特定时间点完成对特定用户的身份验证）。

# 架构

Android Keystore API 和底层 Keymaster HAL 提供了一套基本的但足以满足需求的加密基元，以便使用访问受控且由硬件支持的密钥实现相关协议。

Keymaster HAL 是由原始设备制造商 (OEM) 提供的动态加载库，Keystore 服务使用它来提供由硬件支持的加密服务。为了确保安全性，HAL 实现不会在用户空间乃至内核空间中执行任何敏感操作。敏感操作会被分配给通过某个内核接口连接的安全处理器。最终的架构如下所示：

![0001_access_to_keymaster.png](images/0001_access_to_keymaster.png)

在 Android 设备中，Keymaster HAL 的“客户端”包含多个层（例如，应用、框架、密钥库守护程序），但在本文档中可以将其忽略。这意味着，所介绍的 Keymaster HAL API 为底层 API，供平台内部组件使用，不面向应用开发者提供。Android 开发者网站对更高层 API 进行了介绍。

Keymaster HAL 的目的不是实现安全敏感型算法，而只是对发送到安全域的请求进行编排和解排。传输格式是由实现定义的。

# 调用关系

```
cts apk进程通过API ==> Framework Keystore API
Framework Keystore API 通过Binder调用 ==> Keystore进程
Keystore进程通过HIDL ==> Keymaster HAL进程
Keymaster HAL进程  ==> 调用TEE中的keymaster TA
```

# cts keystore

* 列举当前系统支持的测试包：pm list instrumentation
* product package
  ```
  * cts/tests/tests/keystore/Android.bp
    * android_test
      * name: "CtsKeystoreTestCases",
  ```

# keystore APP使用

```java
KeyStore keyStore = null;
String TAG = "zengjf";

@Override
protected void onCreate(Bundle savedInstanceState) {
    // ...省略

    try {
        keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);
        Log.d(TAG, "keyStore:" + keyStore);

        createKeyPair("key_test");
        getTargetKeyPair("key_test");

        Enumeration<String> aliases = keyStore.aliases();
        while (aliases != null && aliases.hasMoreElements()) {
            String alias = aliases.nextElement();
            Log.d(TAG, "aliases:" + alias);
        }

        keyStore.deleteEntry("key_test");
    } catch (Exception e) {
        e.printStackTrace();
    }

    // ...省略
}

private boolean hasAlias(String alias) {
    try {
        return keyStore != null && keyStore.containsAlias(alias);
    } catch (KeyStoreException e) {
        e.printStackTrace();
    }
    return false;
}

public void createKeyPair(String alias) {
    if (hasAlias(alias)) {
        Log.d(TAG, "createKeyPair exist");
        return;
    }

    KeyPairGenerator keyPairGenerator;
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        try {
            keyPairGenerator = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, "AndroidKeyStore");
            //RSA算法用于签名与校验，具体参考KeyGenParameterSpec类注释
            keyPairGenerator.initialize(new KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_SIGN |
                    KeyProperties.PURPOSE_VERIFY).setDigests(KeyProperties.DIGEST_SHA256, KeyProperties
                    .DIGEST_SHA512).build());
            KeyPair keyPair = keyPairGenerator.generateKeyPair();

            Log.d(TAG, "createKeyPair >> PrivateKey: " + keyPair.getPrivate());
            Log.d(TAG, "createKeyPair >> PublicKey: " + keyPair.getPublic().getFormat());

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public KeyPair getTargetKeyPair(String alias) {
    try {
        KeyStore.PrivateKeyEntry entry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(alias, null);

        PublicKey publicKey = entry.getCertificate().getPublicKey();
        PrivateKey privateKey = entry.getPrivateKey();

        Log.d(TAG, "getTargetKeyPair >> privateKey:" + privateKey);
        Log.d(TAG, "getTargetKeyPair >> publicKey:" + publicKey);

        return new KeyPair(publicKey, privateKey);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
```
