# namespace CLONE_NEWIPC pipe

IPC通信隔离，父子进程怎么通信管理，可以使用匿名pipe

# 参考文档

* [Introduction to Linux namespaces - Part 2: IPC](https://blog.yadutaf.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/)
* [A deep dive into Linux namespaces](http://ifeanyi.co/posts/linux-namespaces-part-1/)
* [Linux 的进程间通信：管道](https://zhuanlan.zhihu.com/p/58489873)
  * 管道实际上可以实现一个半双工通信的机制

# 简要说明

Activating the IPC namespace is only a matter of adding "CLONE_NEWIPC" to the "clone" call. It requires no additional setup. It may also be freely combined with other namespaces.

Once activated, you are free to create any IPC as usual, even named one, without any risk of collision with other applications.

But, WAIT! My "parent process" is now isolated from my "child process" right ? What if I need to do some kind of communication between them ?

That’s a good question. A common use case for this is you need some additional setup from the parent before letting the child take full control. Fortunately, not everything is isolated and clone shares memory space with its parent so that you can still use:

* signal
* poll memory
* sockets
* use files and file-descriptors

Because of it’s context changes, signaling is probably not the most practical one while polling memory is damn inefficient way of communicating !

# 示例

```cpp
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <sched.h>
#include <signal.h>
#include <unistd.h>

#define STACK_SIZE (1024 * 1024)

// sync primitive
int checkpoint[2];

static char child_stack[STACK_SIZE];
char* const child_args[] = {
  "/bin/bash",
  NULL
};

int child_main(void* arg)
{
  char c;

  // init sync primitive
  close(checkpoint[1]);
  // wait...
  read(checkpoint[0], &c, 1);

  printf(" - World !\n");
  // sethostname("In Namespace", 12);
  // execv(child_args[0], child_args);
  printf("Ooops\n");
  return 1;
}

int main()
{
  // init sync primitive
  pipe(checkpoint);

  printf(" - Hello ?\n");

  int child_pid = clone(child_main, child_stack+STACK_SIZE,
      CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL);

  // some damn long init job
  sleep(4);
  // signal "done"
  close(checkpoint[1]);

  waitpid(child_pid, NULL, 0);
  return 0;
}
```
